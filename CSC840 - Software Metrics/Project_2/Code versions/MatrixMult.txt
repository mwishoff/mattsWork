/*
* Class: CSC 840
* By: Matthew Wishoff
* Date: 3/4/2016
* Description: This will be seeing which way to calculate matrix multiplication is the fastest
*/


#include <iostream>
#include <chrono>

using namespace std;

#define numOfTests 6

int main(int argc, char**argv)
{
	chrono::steady_clock::time_point startTime, stopTime;
	
	int col = 0;
	int nmin = 100;
	int nmax = 400;
	int step = 20;
	int M;
	double RUN_TIME[numOfTests][((nmax - nmin) / step) + 1];

	// Initialize a[ ][ ] and b[ ][ ]
	for(int row=0, n=nmin; n <= nmax; n+=step, col++) //increase size of matrix
	{
		M =(nmax*nmax*nmax)/(n*n*n);
		
		double** a = new double*[n]; //Initialize to the min, the next iteration will step by 20
		double** b = new double*[n]; //Initialize to the min, the next iteration will step by 20
		double** c = new double*[n]; //Initialize to the min, the next iteration will step by 20  
		
		cout << "before init" << endl;
		for(int i = 0; i < n; i++)
		{
			a[i] = new double[n];
			b[i] = new double[n];
			c[i] = new double[n];
		}
	
		for(int i=0; i<n; i++) // Matrix c[ ][ ] initialization
			for(int j=0; j<n; j++)
			{
				//Initialize diagonal to 2.0002, and everywhere else to 1.0001
				if(i == j)
				{
					a[i][j] = 2.0002;
					b[i][j] = 2.0002;
				}
				else
				{
					a[i][j] = 1.0001;
					b[i][j] = 1.0001;
				}
				
				c[i][j]=0.0; 
			} 
				
		
		
		startTime = chrono::steady_clock::now(); //Start timer
		for(int m=0; m<M; m++) // Repeat M times
			for(int i=0; i<n; i++) // Basic i-j-k form
				for(int j=0; j<n; j++)
					for(int k=0; k<n; k++)
					{
						c[i][j] += a[i][k]*b[k][j];
						// c[i][j] += a[i][k]*b[j][k];
						//c[i][j] += a[k][i]*b[k][j];
						// c[i][j] += a[k][i]*b[j][k];
						// c[j][i] += a[i][k]*b[k][j];
						// c[j][i] += a[i][k]*b[j][k];
						// c[j][i] += a[k][i]*b[k][j];
						// c[j][i] += a[k][i]*b[j][k];
					}					
						
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[0][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		cout << RUN_TIME[0][0] << endl;
		
		startTime = chrono::steady_clock::now(); //Start timer
		for(int m=0; m<M; m++) // Repeat M times
			for(int i=0; i<n; i++) // Basic i-k-j form
				for(int k=0; k<n; k++)
					for(int j=0; j<n; j++)
					{
						c[i][j] += a[i][k]*b[k][j];
						// c[i][j] += a[i][k]*b[j][k];
						// c[i][j] += a[k][i]*b[k][j];
						// c[i][j] += a[k][i]*b[j][k];
						// c[j][i] += a[i][k]*b[k][j];
						// c[j][i] += a[i][k]*b[j][k];
						// c[j][i] += a[k][i]*b[k][j];
						// c[j][i] += a[k][i]*b[j][k];
					}
					
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[1][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		cout << RUN_TIME[1][0] << endl;
		
		startTime = chrono::steady_clock::now(); //Start timer
		for(int m=0; m<M; m++) // Repeat M times
			for(int k=0; k<n; k++) // Basic k-j-i form
				for(int j=0; j<n; j++)
					for(int i=0; i<n; i++)
					{
						c[i][j] += a[i][k]*b[k][j];
						// c[i][j] += a[i][k]*b[j][k];
						// c[i][j] += a[k][i]*b[k][j];
						// c[i][j] += a[k][i]*b[j][k];
						// c[j][i] += a[i][k]*b[k][j];
						// c[j][i] += a[i][k]*b[j][k];
						// c[j][i] += a[k][i]*b[k][j];
						// c[j][i] += a[k][i]*b[j][k];
					}
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[2][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		cout << RUN_TIME[2][0] << endl;
		
		startTime = chrono::steady_clock::now(); //Start timer
		for(int m=0; m<M; m++) // Repeat M times
			for(int k=0; k<n; k++) // Basic k-i-j form
				for(int i=0; i<n; i++)
					for(int j=0; j<n; j++)
					{
						c[i][j] += a[i][k]*b[k][j];
						// c[i][j] += a[i][k]*b[j][k];
						// c[i][j] += a[k][i]*b[k][j];
						// c[i][j] += a[k][i]*b[j][k];
						// c[j][i] += a[i][k]*b[k][j];
						// c[j][i] += a[i][k]*b[j][k];
						// c[j][i] += a[k][i]*b[k][j];
						// c[j][i] += a[k][i]*b[j][k];
					}
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[3][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		cout << RUN_TIME[3][0] << endl;
		
		startTime = chrono::steady_clock::now(); //Start timer
		for(int m=0; m<M; m++) // Repeat M times
			for(int j=0; j<n; j++) // Basic j-k-i form
				for(int k=0; k<n; k++)
					for(int i=0; i<n; i++)
					{
						c[i][j] += a[i][k]*b[k][j];
						// c[i][j] += a[i][k]*b[j][k];
						// c[i][j] += a[k][i]*b[k][j];
						// c[i][j] += a[k][i]*b[j][k];
						// c[j][i] += a[i][k]*b[k][j];
						// c[j][i] += a[i][k]*b[j][k];
						// c[j][i] += a[k][i]*b[k][j];
						// c[j][i] += a[k][i]*b[j][k];
					}
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[4][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		cout << RUN_TIME[4][0] << endl;
		
		startTime = chrono::steady_clock::now(); //Start timer
		for(int m=0; m<M; m++) // Repeat M times
			for(int j=0; j<n; j++) // Basic j-i-k form
				for(int i=0; i<n; i++)
					for(int k=0; k<n; k++)
					{
						c[i][j] += a[i][k]*b[k][j];
						// c[i][j] += a[i][k]*b[j][k];
						// c[i][j] += a[k][i]*b[k][j];
						// c[i][j] += a[k][i]*b[j][k];
						// c[j][i] += a[i][k]*b[k][j];
						// c[j][i] += a[i][k]*b[j][k];
						// c[j][i] += a[k][i]*b[k][j];
						// c[j][i] += a[k][i]*b[j][k];
					}
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[5][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		cout << RUN_TIME[5][0] << endl;
		
		//Delete dynamic array of pointers.
		for(int i = 0; i < n; i++)
		{
				delete[] a[i];
				delete[] b[i];
				delete[] c[i];
		}
		delete[] a;
		delete[] b;
		delete[] c;
			
	}
	//Pipe the RUN_TIME 2D array out into a text file.
	freopen ("MatrixTest8.txt","w",stdout);
	
	for(int i = 0; i < 6; i++) // this is correct
	{
		for(int j = 0; j <= (nmax - nmin) / step; j++)
		{
			cout << RUN_TIME[i][j] << ", "; //Print a row of data
		}
		cout << endl;
	}
	fclose (stdout);
}

