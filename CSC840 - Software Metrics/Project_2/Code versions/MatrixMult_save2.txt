/*
* Class: CSC 840
* By: Matthew Wishoff
* Date: 3/4/2016
* Description: This will be seeing which way to calculate matrix multiplication is the fastest
*/


#include <iostream>
#include <stdio.h>
#include <chrono>

using namespace std;

#define DO_MULTIPLY_1	 	\
	c[i][j] += a[i][k]*b[k][j]

#define DO_MULTIPLY_2 		\
	c[i][j] += a[i][k]*b[j][k]
	
#define DO_MULTIPLY_3	 	\
	c[i][j] += a[k][i]*b[k][j]
	
#define DO_MULTIPLY_4	 	\
	c[i][j] += a[k][i]*b[j][k]
	
#define DO_MULTIPLY_5	 	\
	c[j][i] += a[i][k]*b[k][j]
	
#define DO_MULTIPLY_6	 	\
	c[j][i] += a[i][k]*b[j][k]
	
#define DO_MULTIPLY_7	 	\
	c[j][i] += a[k][i]*b[k][j]
	
#define DO_MULTIPLY_8	 	\
	c[j][i] += a[k][i]*b[j][k]


#define DO_MULTIPLY_IJK(method)	 			\
	for(int m=0; m<M; m++)  				\
			for(int i=0; i<n; i++) 			\
				for(int j=0; j<n; j++) 		\
					for(int k=0; k<n; k++)	\
						DO_MULTIPLY_##method;
						
						
#define DO_MULTIPLY_IKJ(method)	 			\
	for(int m=0; m<M; m++) 					\
			for(int i=0; i<n; i++) 			\
				for(int k=0; k<n; k++)		\
					for(int j=0; j<n; j++)	\
						DO_MULTIPLY_##method;
						
#define DO_MULTIPLY_KJI(method)	 			\
	for(int m=0; m<M; m++)					\
			for(int k=0; k<n; k++) 			\
				for(int j=0; j<n; j++)		\
					for(int i=0; i<n; i++)	\
						DO_MULTIPLY_##method;
						
#define DO_MULTIPLY_KIJ(method)	 			\
	for(int m=0; m<M; m++) 					\
			for(int k=0; k<n; k++) 			\
				for(int i=0; i<n; i++)		\
					for(int j=0; j<n; j++)	\
						DO_MULTIPLY_##method;
						
#define DO_MULTIPLY_JKI(method)	 			\
	for(int m=0; m<M; m++) 					\
			for(int j=0; j<n; j++) 			\
				for(int k=0; k<n; k++)		\
					for(int i=0; i<n; i++)	\
						DO_MULTIPLY_##method;
						
#define DO_MULTIPLY_JIK(method)	 			\
	for(int m=0; m<M; m++) 					\
			for(int j=0; j<n; j++) 			\
				for(int i=0; i<n; i++)		\
					for(int k=0; k<n; k++)	\
						DO_MULTIPLY_##method;
						
#define MULTIPLY(method) 		\
	startTime = chrono::steady_clock::now(); \
	DO_MULTIPLY_IJK(method)	 	\
	DO_MULTIPLY_IKJ(method)	 	\
	DO_MULTIPLY_KJI(method)	 	\
	DO_MULTIPLY_KIJ(method)	 	\
	DO_MULTIPLY_JKI(method)	 	\
	DO_MULTIPLY_JIK(method)	 	\
						
	
#define NUM_OF_TESTS (8*6)
#define NMAX 500
#define NMIN 100
#define STEP 20

int TEST_NUM = 0;
double RUN_TIME[NUM_OF_TESTS][((NMAX - NMIN) / STEP) + 1];

void DoMultiply(int M, int n, double **a, double **b, double **c, int col);
void DoMultiply1(int M, int n, double **a, double **b, double **c, int col);
void DoMultiply2(int M, int n, double **a, double **b, double **c, int col);
void DoMultiply3(int M, int n, double **a, double **b, double **c, int col);
void DoMultiply4(int M, int n, double **a, double **b, double **c, int col);
void DoMultiply5(int M, int n, double **a, double **b, double **c, int col);
void DoMultiply6(int M, int n, double **a, double **b, double **c, int col);
void DoMultiply7(int M, int n, double **a, double **b, double **c, int col);
void DoMultiply8(int M, int n, double **a, double **b, double **c, int col);

int main(int argc, char**argv)
{
//	chrono::steady_clock::time_point startTime, stopTime;
	
	int col = 0;
//	int nmin = 100;
//	int nmax = 400;
//	int step = 20;
	int M;
//	double RUN_TIME[numOfTests][((NMAX - NMIN) / STEP) + 1];

	// Initialize a[ ][ ] and b[ ][ ]
	for(int n=NMIN; n <= NMAX; n+=STEP, col++) //increase size of matrix
	{
		M =(NMAX*NMAX*NMAX)/(n*n*n);
		
		double** a = new double*[n]; //Initialize to the min, the next iteration will step by 20
		double** b = new double*[n]; //Initialize to the min, the next iteration will step by 20
		double** c = new double*[n]; //Initialize to the min, the next iteration will step by 20  
		
		cout << "before init" << endl;
		for(int i = 0; i < n; i++)
		{
			a[i] = new double[n];
			b[i] = new double[n];
			c[i] = new double[n];
		}
	
		for(int i=0; i<n; i++) // Matrix c[ ][ ] initialization
			for(int j=0; j<n; j++)
			{
				//Initialize diagonal to 2.0002, and everywhere else to 1.0001
				if(i == j)
				{
					a[i][j] = 2.0002;
					b[i][j] = 2.0002;
				}
				else
				{
					a[i][j] = 1.0001;
					b[i][j] = 1.0001;
				}
				
				c[i][j]=0.0; 
			} 
		//What I want
		DoMultiply(M, n, a, b, c, col);
			
			
			
//		DoMultiply1(M, n, a, b, c, col);
//		DoMultiply2(M, n, a, b, c, col);
//		DoMultiply3(M, n, a, b, c, col);
//		DoMultiply4(M, n, a, b, c, col);
//		DoMultiply5(M, n, a, b, c, col);
//		DoMultiply6(M, n, a, b, c, col);
//		DoMultiply7(M, n, a, b, c, col);
//		DoMultiply8(M, n, a, b, c, col);
		
		//Delete dynamic array of pointers.
		for(int i = 0; i < n; i++)
		{
				delete[] a[i];
				delete[] b[i];
				delete[] c[i];
		}
		delete[] a;
		delete[] b;
		delete[] c;
			
	}
	
	//Pipe the RUN_TIME 2D array out into a text file.
	freopen ("MaidenVoyage.txt","w",stdout);
	
	for(int i = 0; i < NUM_OF_TESTS; i++) // this is correct
	{
		for(int j = 0; j <= (NMAX - NMIN) / STEP; j++)
		{
			cout << RUN_TIME[i][j] << ", "; //Print a row of data
		}
		cout << endl;
	}
	cout << endl;
	fclose (stdout);
}

void DoMultiply(int M, 
				 int n, 
				 double **a,
				 double **b,
				 double **c,
				 int col)
{
	chrono::steady_clock::time_point startTime, stopTime;
	startTime = chrono::steady_clock::now(); //Start timer
		MULTIPLY(1);
	stopTime = chrono::steady_clock::now(); //Stop timer
	RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
}

void DoMultiply1(int M, 
				 int n, 
				 double **a,
				 double **b,
				 double **c,
				 int col)
{
		chrono::steady_clock::time_point startTime, stopTime;
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IJK(1);	
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IKJ(1);			
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KJI(1);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KIJ(1);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JKI(1);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JIK(1);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
}

void DoMultiply2(int M, 
				 int n, 
				 double **a,
				 double **b,
				 double **c,
				 int col)
{
		chrono::steady_clock::time_point startTime, stopTime;
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IJK(2);	
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IKJ(2);			
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KJI(2);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KIJ(2);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JKI(2);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JIK(2);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
}

void DoMultiply3(int M, 
				 int n, 
				 double **a,
				 double **b,
				 double **c,
				 int col)
{
		chrono::steady_clock::time_point startTime, stopTime;
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IJK(3);	
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IKJ(3);			
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KJI(3);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KIJ(3);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JKI(3);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JIK(3);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
}

void DoMultiply4(int M, 
				 int n, 
				 double **a,
				 double **b,
				 double **c,
				 int col)
{
		chrono::steady_clock::time_point startTime, stopTime;
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IJK(4);	
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IKJ(4);			
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KJI(4);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KIJ(4);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JKI(4);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JIK(4);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
}

void DoMultiply5(int M, 
				 int n, 
				 double **a,
				 double **b,
				 double **c,
				 int col)
{
		chrono::steady_clock::time_point startTime, stopTime;
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IJK(5);	
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IKJ(5);			
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KJI(5);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KIJ(5);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JKI(5);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JIK(5);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
}

void DoMultiply6(int M, 
				 int n, 
				 double **a,
				 double **b,
				 double **c,
				 int col)
{
		chrono::steady_clock::time_point startTime, stopTime;
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IJK(6);	
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IKJ(6);			
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KJI(6);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KIJ(6);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JKI(6);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JIK(6);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
}

void DoMultiply7(int M, 
				 int n, 
				 double **a,
				 double **b,
				 double **c,
				 int col)
{
		chrono::steady_clock::time_point startTime, stopTime;
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IJK(7);	
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IKJ(7);			
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KJI(7);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KIJ(7);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JKI(7);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JIK(7);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
}

void DoMultiply8(int M, 
				 int n, 
				 double **a,
				 double **b,
				 double **c,
				 int col)
{
		chrono::steady_clock::time_point startTime, stopTime;
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IJK(8);	
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_IKJ(8);			
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KJI(8);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_KIJ(8);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JKI(8);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
		startTime = chrono::steady_clock::now(); //Start timer
			DO_MULTIPLY_JIK(8);
		stopTime = chrono::steady_clock::now(); //Stop timer
		RUN_TIME[TEST_NUM++ % NUM_OF_TESTS][col] = chrono::duration_cast<chrono::duration<double>>(stopTime - startTime).count() / M;
		
}
